#!/usr/bin/python3
import PluginManager
import OutputManager
import os
import Data
import threading
import time

MAX_THREADS = 4


def get_plugin_funcs():
    if os.path.exists(os.getcwd() + f'/{PluginManager.CHECK_DEVICE_NAME}.py'):  # Check if it actually exists.
        try:
            from CheckDevice import ALL_FUNCS  # Try to import.
        except ModuleNotFoundError as e:  # Error in Check Device plugin imports.
            raise Exception(f'Plugin files missing from the specified plugin folder!\n\t( {e} )\nAborting...')
        # Catch any other error (could be function 'check' does not exist in a plugin module)
        except Exception as error:
            raise Exception(f'{error} \n\tAborting...')
        finally:
            return ALL_FUNCS  # Get and return the list of all plugin functions from Check Device.
    else:  # Check file does not exist.
        raise Exception(f'Check device does not exist!\n\t({PluginManager.CHECK_DEVICE_NAME}.py)\nAborting...')


def logic(data: Data.Data):
    mutex = threading.Lock()  # Whenever a plugin is using data object
    plugins = get_plugin_funcs()  # List of the functions of the plugins
    threads = list()
    for plugin in plugins:
        threads.append(threading.Thread(target=plugin, args=(data, mutex)))

    info = [len(threads), False]  # [number of plugins, the threads finished their run?]
    output = threading.Thread(target=OutputManager.logic, args=(data, mutex, info))
    output.start()  # Output manager waits for results

    index = 0  # Current index in the threads list
    while True:
        alive = 0
        for thread in threads:
            if thread.isAlive():
                alive += 1
        if alive < MAX_THREADS and index < len(threads):
            # If we can add more threads to the process and there are more threads to add
            threads[index].start()
            index += 1
        elif alive == 0:  # All the threads finished their work
            break

    info[1] = True  # Signalling the output manager that the threads finished their job
    output.join()  # Waiting for the Output manager to finish it's job
